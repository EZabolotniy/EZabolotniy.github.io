<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>iOS Developer Notes</title><description>Articles about Swift and iOS Development</description><link>https://ezabolotniy.github.io</link><language>en</language><lastBuildDate>Sun, 9 Apr 2023 07:30:41 +0000</lastBuildDate><pubDate>Sun, 9 Apr 2023 07:30:41 +0000</pubDate><ttl>250</ttl><atom:link href="https://ezabolotniy.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://ezabolotniy.github.io/blog/briging/briging</guid><title>Swift String vs NSString</title><description>In this post you'll learn about implicit bridging between Swift String and NSString and its costs</description><link>https://ezabolotniy.github.io/blog/briging/briging</link><pubDate>Sun, 9 Apr 2023 14:47:00 +0000</pubDate><content:encoded><![CDATA[<h1>Swift String vs NSString</h1><p>While I was implementing a <a href="https://github.com/EZabolotniy/hack-assembler">Hack Assempler</a> I had to parse an assembly code file, which looks like this:</p><pre><code><span class="comment">// Computes R2 = max(R0, R1)  (R0,R1,R2 refer to RAM[0],RAM[1],RAM[2])</span>

   <span class="keyword">@R0</span>
   <span class="type">D</span>=<span class="type">M</span>              <span class="comment">// D = first number</span>
   <span class="keyword">@R1</span>
   <span class="type">D</span>=<span class="type">D</span>-<span class="type">M</span>            <span class="comment">// D = first number - second number</span>
   <span class="keyword">@OUTPUT_FIRST</span>
   <span class="type">D</span>;<span class="type">JGT</span>            <span class="comment">// if D&gt;0 (first is greater) goto output_first</span>
   <span class="keyword">@R1</span>
   <span class="type">D</span>=<span class="type">M</span>              <span class="comment">// D = second number</span>
   <span class="keyword">@OUTPUT_D</span>
   <span class="number">0</span>;<span class="type">JMP</span>            <span class="comment">// goto output_d</span>
(<span class="type">OUTPUT_FIRST</span>)
   <span class="keyword">@R0</span>             
   <span class="type">D</span>=<span class="type">M</span>              <span class="comment">// D = first number</span>
(<span class="type">OUTPUT_D</span>)
   <span class="keyword">@R2</span>
   <span class="type">M</span>=<span class="type">D</span>              <span class="comment">// M[2] = D (greatest number)</span>
(<span class="type">INFINITE_LOOP</span>)
   <span class="keyword">@INFINITE_LOOP</span>
   <span class="number">0</span>;<span class="type">JMP</span>            <span class="comment">// infinite loop</span>
</code></pre><p>The purpose of parsing was to extract all assemply commands and translate them to its binary form. So, the parser goes line by line and the first thing it does is trimming whitespaces and removing a comment. The first solution I came up with was this code:</p><pre><code><span class="keyword">extension</span> <span class="type">String</span> {
  <span class="keyword">func</span> removeComments() -&gt; <span class="type">String</span> {
    <span class="keyword">let</span> trimmedWhitespacesAndNewlines = <span class="call">trimmingCharacters</span>(in: .<span class="dotAccess">whitespacesAndNewlines</span>)
    <span class="keyword">guard</span> !trimmedWhitespacesAndNewlines.<span class="call">hasPrefix</span>(<span class="string">"</span><span class="comment">//") else {</span>
      <span class="keyword">return</span> <span class="string">""</span>
    }
    <span class="comment">// code and comment on a single line:</span>
    <span class="keyword">return</span> trimmedWhitespacesAndNewlines.<span class="call">components</span>(separatedBy: <span class="string">"</span><span class="comment">//").first!</span>
      .<span class="call">trimmingCharacters</span>(in: .<span class="dotAccess">whitespacesAndNewlines</span>)
  }
}
</code></pre><p>Let's go through it line by line. First I call <code>trimmingCharacters(in: .whitespacesAndNewlines)</code>, which trims whitespaces and newlines. Then I check if it starts with <code>//</code> and if so, I just return an empty string because the whole line is just a comment. Otherwise I try splitting the trimmed string with "//" in case it has trailing comment, take the part before a comment, trim whitespaces and newlines in that part and return it. Not elegant but straightforward and works correctly. So I decided to measure the performance of this function. Let's take a string and parse it a million times.</p><pre><code><span class="keyword">let</span> clock = <span class="type">ContinuousClock</span>()
<span class="keyword">let</span> elapsedTime = clock.<span class="call">measure</span> {
  <span class="keyword">for _ in</span> <span class="number">0</span>..&lt;<span class="number">1000000</span> {
    <span class="keyword">let _</span> = <span class="string">"push local 1</span>  <span class="comment">// Test trailing comment Test trailing comment Test trailing comment Test trailing comment".removeComments()</span>
  }
}
<span class="call">print</span>(<span class="string">"ElapsedTime =</span> \(elapsedTime)<span class="string">"</span>)
</code></pre><p>Build and run in release mode <code>swift run -c release</code>:</p><pre><code><span class="type">ElapsedTime</span> = <span class="number">3.776673785</span> seconds
</code></pre><p>Build in release mode <code>swift build -c release</code> and run with Intruments:</p><img src="https://ezabolotniy.github.io/blog/briging/trimming.png" alt="Trimming"/><p><br><img src="https://ezabolotniy.github.io/blog/briging/components.png" alt="Components"/> <br><br>Here, we can see that calling <code>func trimmingCharacters(in set: CharacterSet) -&gt; String</code> on a <code>String</code> actually calls <code>- (NSString *)stringByTrimmingCharactersInSet:(NSCharacterSet *)set;</code> on <code>NSString</code>. And the same happens with <code>func components(separatedBy separator: CharacterSet) -&gt; [String]</code>, it is transformed into <code>- (NSArray&lt;NSString *&gt; *)componentsSeparatedByString:(NSString *)separator;</code> call on <code>NSString</code>. This is what Objc-Swift Interoperability is responsible of. To make this possible Swift <code>String</code> is bridged into <code>NSString</code> by allocating a new storage with size of the <code>String</code> on the heap, and copying each chatacter into that new storage. So calling an <code>NSString</code> method on a <code>String</code> instance has cpu and memory overhead by creating a new <code>NSString</code> and then converting <code>NSString</code> back into Swift <code>String</code>. Let's try to solve this problem by staying in a Swift world, thus removing the bridging overhead.</p><pre><code><span class="keyword">extension</span> <span class="type">String</span> {
  <span class="keyword">func</span> removeComments() -&gt; <span class="type">String</span> {
    <span class="keyword">var</span> commentStartIndex = endIndex
    <span class="keyword">for</span> i <span class="keyword">in</span> indices.<span class="call">dropFirst</span>() {
      <span class="keyword">if self</span>[i] == <span class="string">"/"</span> &amp;&amp; <span class="keyword">self</span>[<span class="call">index</span>(before: i)] == <span class="string">"/"</span> {
        commentStartIndex = <span class="call">index</span>(before: i)
        <span class="keyword">break</span>
      }
    }

    <span class="keyword">let</span> noCommentString = <span class="keyword">self</span>[..&lt;commentStartIndex]
    <span class="keyword">if let</span> firstLetterIndex = noCommentString.<span class="call">firstIndex</span>(where: { $!$0.<span class="property">isWhitespace</span> }),
       <span class="keyword">let</span> lastLetterIndex = noCommentString.<span class="call">lastIndex</span>(where: { !$0.<span class="property">isWhitespace</span> }) {
      <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>[firstLetterIndex...lastLetterIndex])
    }
    <span class="keyword">return</span> <span class="string">""</span>
  }
}
</code></pre><p>Build and run in release mode <code>swift run -c release</code>:</p><pre><code><span class="type">ElapsedTime</span> = <span class="number">1.078179221</span> seconds
</code></pre><p>As we can see the latter code runs 3.5 times faster and does not waste memory on briging. So, measure your code and stay in Swift world!</p><p>References:<br>1. <a href="https://developer.apple.com/wwdc18/229">WWDC18 Using Collections Effectively</a> (timecode: 30:10)</p>]]></content:encoded></item></channel></rss>