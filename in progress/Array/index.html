<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="iOS Developer Notes"/><link rel="canonical" href="https://ezabolotniy.github.io/in%20progress/Array"/><meta name="twitter:url" content="https://ezabolotniy.github.io/in%20progress/Array"/><meta name="og:url" content="https://ezabolotniy.github.io/in%20progress/Array"/><title>Array, ContiguousArray and ArraySlice | iOS Developer Notes</title><meta name="twitter:title" content="Array, ContiguousArray and ArraySlice | iOS Developer Notes"/><meta name="og:title" content="Array, ContiguousArray and ArraySlice | iOS Developer Notes"/><meta name="description" content="In this post you'll learn array types and its internals in Swift"/><meta name="twitter:description" content="In this post you'll learn array types and its internals in Swift"/><meta name="og:description" content="In this post you'll learn array types and its internals in Swift"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to iOS Developer Notes"/></head><body><header><div class="wrapper"><a href="/" class="site-name">iOS Developer Notes</a><nav><ul><li><a href="/Structures">Structures</a></li><li><a href="/interview">CrackingTheCodingInterview</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><h1>Array, ContiguousArray and ArraySlice</h1><p>Массив это один из самых часто используемых типов данных, поэтому важно понимать как он устроен.</p><p>В классическом представлении массив это непрерывный кусок памяти, который частично или полностью заполнен данными. В языке С мы можем выделять память с помощью функции malloc:</p><pre><code>char *p = <span class="call">malloc</span>(<span class="number">4</span>);  <span class="comment">// allocates enough for an array of 4 bytes</span>
<span class="call">for</span>(int n=<span class="number">0</span>; n&lt;<span class="number">4</span>; ++n) <span class="comment">// populate the array with a,b,c,d values</span>
  p[n] = ‘a’+n;
<span class="call">printf</span>(<span class="string">"%c \n"</span>, p[<span class="number">3</span>]);
</code></pre><p>Переменная <code>p</code>, содержит адрес нулевого байта массива, тогда <code>p+1</code> – это адрес 1-го байта, <code>p+n</code> – адрес n-го байта массива.</p><pre><code><span class="call">printf</span>(<span class="string">"%c \n"</span>, *(p + <span class="number">3</span>));
</code></pre><p>Таким образом последовательное хранение элементов в памяти дает нам возможность реализовать массив с максимально быстрым доступом к его элементам, потому что для вычисления адреса элемента массива нужно выполнить всего одну операцию сложения. Естественно эта операция выполняется за константное время (O(1)). Но у последовательного хранения элементов массива есть и недостатки. Например, для того чтобы реализовать добавление нового элемента в начало массива, необходимо все текущие элементы переместить на один индекс вперед, что делает эту операцию зависимой от размера массива (O(n)).</p><img src="Insertion.png" alt="Insertion"/><p>Так же при удалении начального элемента массива, придется перемещать оставшиеся элемента на один индекс назад, чтобы сохранить адрес нулевого элемента массива прежним, что так же делает эту операцию зависимой от размера массива (O(n)).</p><img src="Removal.png" alt="Removal"/><p>Существуют такие реализации массива, которые позволяют осуществлять добавление и удаление в начало и конец массива за константное время без копирования всех элементов, но все эти реализацию жертвуют временем доступа к произвольному элементу массива и имеет ряд других ограничений. Поэтому для каждой задачи нужно выбирать такой тип массива, который лучше всего для нее подходит.</p><p>Обладая этими знаниями, вернемся в мир Swift и рассмотрим как там реализован массив.</p><p>При реализации типа данных Array из стандартной библиотеки Swift, команда разработчиков ставила для себя следующие цели:</p><ol><li>Реализовать доступ к произвольным элементам массива с такой же скоростью как в языке С.</li><li>Реализовать возможность преобразовывать NSArray в <code>Array&lt;AnyObject&gt;</code> и обратно за O(1) по времени и без выделение дополнительной памяти.</li><li>Реализовать операции добавления в конец массива и удаления последнего элемента массива за амортизировано константное время (amortized O(1)), чтобы массив можно было эффективно использовать как стэк.</li></ol><p>В итоге, было реализовано три типа массивов: <code>Array&lt;Element&gt;</code>, <code>ContiguousArray&lt;Element&gt;</code> и <code>ArraySlice&lt;Element&gt;</code>.</p><p><code>ContiguousArray&lt;Element&gt;</code> самый быстрый и простой из трех, он всегда хранит свои элементы последовательно в памяти и имеет те же преимущества и недостатки что мы рассматривали у массива в языке С.</p><img src="ContiguousArray.png" alt="ContiguousArray"/><p><code>Array&lt;Element&gt;</code> создан с целью эффективной конвертации в Cocoa и обратно, поэтому для хранения элементов он использует либо <code>NSArray</code> либо <code>ContiguousArray&lt;Element&gt;</code>. Если <code>Element</code> является классом, то для хранения будет использовать <code>NSArray</code>, чтобы реализовать возможность преобразовывать <code>NSArray</code> в <code>Array&lt;AnyObject&gt;</code> и обратно за O(1) по времени и без выделение дополнительной памяти (вторая цель). Если известно что <code>Element</code> не будет являться классом, тогда массив не сможет быть переден в Cocoa и поэтому нет необходимости использовать NSArray и будет использовать более быстрый <code>ContiguousArray&lt;Element&gt;</code>.</p><img src="Interoperability.png" alt="Interoperability"/><p>Как устроен <code>NSArray (NSMutableArray)</code> можно подробно прочитать <a href="https://ciechanow.ski/exposing-nsmutablearray/">здесь</a>, если коротко, то <code>NSArray</code> реализован как <a href="https://en.wikipedia.org/wiki/Circular_buffer">circular buffer</a>, поэтому он не хранит элементы последовательно в памяти, но такая реализация дает возможность добавления (и удаления) элемента по индексу 0 за O(1), в то время как добавление элемента по индексу 0 занимает O(n) для <code>ContiguousArray&lt;Element&gt;</code>.</p><p><code>ArraySlice&lt;Element&gt;</code> представлять собой некоторую часть (subrange) от <code>Array&lt;Element&gt;</code> или <code>ContiguousArray&lt;Element&gt;</code>. <code>ArraySlice&lt;Element&gt;</code> получается в результате слайс операции над массивом, например <code>array[7…21]</code>, где array это <code>Array&lt;Element&gt;</code> или <code>ContiguousArray&lt;Element&gt;</code>. <code>ArraySlice&lt;Element&gt;</code> под капотом хранит элементы в <code>ContiguousArray&lt;Element&gt;</code>, поэтому операция <code>array[7…21]</code> выполняется за O(1) во всех случаях кроме одного: когда <code>Array&lt;Element&gt;</code> использует <code>NSArray</code> в качестве хранилища. <code>ArraySlice</code> рекомендуется использовать для локального использования, а не для долговременного хранения элементов. Так же нужно помнить что <code>ArraySlice</code> хранит сильную ссылку на хранилище элементов, тем самым продлевая им жизнь, до тех пор пока сам <code>ArraySlice</code> не высвободится из памяти.</p><img src="ArraySlice.png" alt="ArraySlice"/><p>Ссылки:</p><ol><li><a href="https://ciechanow.ski/exposing-nsmutablearray/">https://ciechanow.ski/exposing-nsmutablearray/</a></li><li><a href="https://en.wikipedia.org/wiki/Circular_buffer">https://en.wikipedia.org/wiki/Circular_buffer</a></li></ol></div><footer></footer></body></html>